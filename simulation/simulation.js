import * as THREE from "https://cdn.jsdelivr.net/npm/three@latest/build/three.module.js";
// import * as THREE from "three";
// Some part of the code is directly taken from the documentation of Threejs (https://threejs.org/docs) with light and or heavy changes.

// General Scene setup
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);

const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const starPhases = [];
const starSpeeds = [];
setupStars();
camera.position.z = 5;
camera.position.x = -15;
renderer.render(scene, camera);
setupCameraMovement();

/**
 * Function which setups the stars geometry by finding: random position, random color, random star animation speed, random star
 */
function setupStars() {
  const starGeometry = new THREE.BufferGeometry();
  const starCount = 5000;
  const positions = [];
  const colors = [];

  // Random Position and Random color
  for (let i = 0; i < starCount; i++) {
    const x = Math.floor((Math.random() - 0.5) * 1000);
    const y = Math.floor((Math.random() - 0.5) * 1000);
    const z = Math.floor((Math.random() - 0.5) * 1000);

    if (Math.sqrt(x * x + y * y + z * z) < 75) {
      continue;
    }

    positions.push(x, y, z);

    // White 50% Chance
    let r = 0.8 + Math.random() * 0.2;
    let g = 0.8 + Math.random() * 0.2;
    let b = 0.8 + Math.random() * 0.2;

    const tintType = Math.floor(Math.random() * 10);
    // Yellow 30% Chance
    if (tintType < 3) {
      b = 153 / 255;
      g = 225 / 255;
      r = 255 / 255;
    }
    // Blue 10% Chance
    else if (tintType === 3) {
      b = 255 / 255;
      g = 51 / 255;
      r = 51 / 255;
    }
    // Red 10% Chance
    else if (tintType === 9) {
      b = 50 / 255;
      g = 50 / 255;
      r = 255 / 255;
    }

    colors.push(r, g, b, 0.8);
    starPhases.push(Math.random() * Math.PI * 2);
    starSpeeds.push(0.001 + Math.random() * 0.0015);
  }

  starGeometry.setAttribute(
    "position",
    new THREE.Float32BufferAttribute(positions, 3)
  );
  starGeometry.setAttribute(
    "color",
    new THREE.Float32BufferAttribute(colors, 4)
  );
  starGeometry.setAttribute(
    "size",
    new THREE.Float32BufferAttribute(new Array(starCount).fill(0.6), 1)
  );

  const starMaterial = new THREE.PointsMaterial({
    size: 0.6,
    vertexColors: true,
    transparent: true,
    opacity: 0.8,
  });

  const stars = new THREE.Points(starGeometry, starMaterial);
  scene.add(stars);
}

/**
 * Function which makes the camera follow the mouse movement in a set window [-1, 1] from the initial point
 */
function setupCameraMovement() {
  let targetRotationX = 0;
  let targetRotationY = 0;
  let currentRotationX = 0;
  let currentRotationY = 0;

  addEventListener("mousemove", (event) => {
    const mouseX = (event.clientX / window.innerWidth) * 2 - 1;
    const mouseY = -(event.clientY / window.innerHeight) * 2 + 1;

    targetRotationY = mouseX * 0.1;
    targetRotationX = mouseY * 0.1;
  });

  let frameCount = 0;
  function animate() {
    requestAnimationFrame(animate);

    currentRotationX += (targetRotationX - currentRotationX) * 0.05;
    currentRotationY += (targetRotationY - currentRotationY) * 0.05;

    camera.rotation.x = currentRotationX;
    camera.rotation.y = -currentRotationY;

    frameCount++;
    if (frameCount % 10 === 0) {
      changeOpacity(scene.children.find((obj) => obj.type === "Points"));
    }
    renderer.render(scene, camera);
  }

  animate();
}

/**
 * Function changes the opacity of 1/4 of the stars every frame based on their star phase and their star speeds.
 * This is to simulate some glowing effect
 * This function was generated by ChatGPT and slightly changed to better match the needs.
 */
function changeOpacity(stars) {
  const colors = stars.geometry.attributes.color.array;

  for (let index = 0; index < colors.length / 4; index++) {
    const alphaIndex = index * 4 + 3;
    colors[alphaIndex] =
      0.3 +
      0.7 *
        Math.abs(Math.sin(Date.now() * starSpeeds[index] + starPhases[index]));
  }

  stars.geometry.attributes.color.needsUpdate = true;
}

// Resizing canva if the screen size is changed
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

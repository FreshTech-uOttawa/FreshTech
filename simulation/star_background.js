// Some part of the code is directly taken from the documentation of Threejs (https://threejs.org/docs) with light and or heavy changes.

// General Scene setup
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);

const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

let isAnimating = true;
const starPhases = [];
const starSpeeds = [];
setupStars();
camera.position.z = 50;
camera.position.x = -10;
camera.position.y = -10;
renderer.render(scene, camera);
setupCameraMovement();

/**
 * Function which setups the stars geometry by finding: random position, random color, random star animation speed, random star
 */
function setupStars() {
  const starGeometry = new THREE.BufferGeometry();
  const starCount = 5000;
  const positions = [];
  const colors = [];

  // Random Position and Random color
  for (let i = 0; i < starCount; i++) {
    const x = Math.floor((Math.random() - 0.5) * 1000);
    const y = Math.floor((Math.random() - 0.5) * 1000);
    const z = Math.floor((Math.random() - 0.5) * 1000);

    if (Math.sqrt(x * x + y * y + z * z) < 75) {
      continue;
    }

    positions.push(x, y, z);

    // White 50% Chance
    let r = 0.8 + Math.random() * 0.2;
    let g = 0.8 + Math.random() * 0.2;
    let b = 0.8 + Math.random() * 0.2;

    const tintType = Math.floor(Math.random() * 10);
    // Yellow 30% Chance
    if (tintType < 3) {
      b = 153 / 255;
      g = 225 / 255;
      r = 255 / 255;
    }
    // Blue 10% Chance
    else if (tintType === 3) {
      b = 255 / 255;
      g = 51 / 255;
      r = 51 / 255;
    }
    // Red 10% Chance
    else if (tintType === 9) {
      b = 50 / 255;
      g = 50 / 255;
      r = 255 / 255;
    }

    colors.push(r, g, b, 0.8);
    starPhases.push(Math.random() * Math.PI * 2);
    starSpeeds.push(0.001 + Math.random() * 0.0015);
  }

  starGeometry.setAttribute(
    "position",
    new THREE.Float32BufferAttribute(positions, 3)
  );
  starGeometry.setAttribute(
    "color",
    new THREE.Float32BufferAttribute(colors, 4)
  );
  starGeometry.setAttribute(
    "size",
    new THREE.Float32BufferAttribute(new Array(starCount).fill(0.6), 1)
  );

  const starMaterial = new THREE.PointsMaterial({
    size: 0.6,
    vertexColors: true,
    transparent: true,
    opacity: 0.8,
  });

  const stars = new THREE.Points(starGeometry, starMaterial);
  scene.add(stars);
}

/**
 * Function which makes the camera follow the mouse movement in a set window [-1, 1] from the initial point
 */
function setupCameraMovement() {
  let targetRotationX = 0;
  let targetRotationY = 0;
  let currentRotationX = 0;
  let currentRotationY = 0;

  addEventListener("mousemove", (event) => {
    if (!isAnimating) {
      return;
    }
    const mouseX = (event.clientX / window.innerWidth) * 2 - 1;
    const mouseY = -(event.clientY / window.innerHeight) * 2 + 1;

    targetRotationY = mouseX * 0.1;
    targetRotationX = mouseY * 0.1;
  });

  let frameCount = 0;
  function animate() {
    if (!isAnimating) {
      return;
    }

    requestAnimationFrame(animate);

    currentRotationX += (targetRotationX - currentRotationX) * 0.05;
    currentRotationY += (targetRotationY - currentRotationY) * 0.05;

    camera.rotation.x = currentRotationX;
    camera.rotation.y = -currentRotationY;

    frameCount++;
    // if (frameCount % 10 === 0) {
    changeOpacity(scene.children.find((obj) => obj.type === "Points"));
    // }
    renderer.render(scene, camera);
  }

  animate();
}

/**
 * Function changes the opacity of 1/4 of the stars every frame based on their star phase and their star speeds.
 * This is to simulate some glowing effect
 * This function was generated by ChatGPT and slightly changed to better match the needs.
 */
function changeOpacity(stars) {
  const colors = stars.geometry.attributes.color.array;

  for (let index = 0; index < colors.length / 4; index++) {
    const alphaIndex = index * 4 + 3;
    const speed = Date.now() * starSpeeds[index] + starPhases[index];
    colors[alphaIndex] = 0.3 + 0.7 * Math.abs(Math.sin(speed));
  }

  stars.geometry.attributes.color.needsUpdate = true;
}

/**
 * Function which simulates travel through space time by moving the camera position forward
 * After the animation is done, it stops all animations and dims the background.
 */
async function beginSimulation() {
  await gsap.to(camera.position, {
    x: 0,
    y: 0,
    z: -300,
    duration: 1.5,
    ease: "power2.in",
  });

  camera.position.set(0, 0, 1300);
  await gsap.to(camera.position, {
    x: 0,
    y: 0,
    z: 0,
    duration: 1.5,
    ease: "power2.Out",
  });

  document.querySelector("canvas").classList.add("dim-background");
  setTimeout(() => {
    isAnimating = false;
  }),
    500;
}

/** Event Listeners */
/** Function which resizes the canva if there was a change to the size of the screen */
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

document
  .querySelector(".begin-simulation-btn")
  .addEventListener("click", beginSimulation);

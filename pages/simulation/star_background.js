// Some part of the code is directly taken from the documentation of Threejs (https://threejs.org/docs) with light and or heavy changes.

// General Scene setup
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);

const renderer = new THREE.WebGLRenderer({
  canvas: document.getElementById("bgCanvas"),
});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

let isSimulationStarted = false;
let isAnimating = true;
const starPhases = [];
const starSpeeds = [];
setupStars();
camera.position.z = 50;
camera.position.x = -10;
camera.position.y = -10;
renderer.render(scene, camera);
setupCameraMovement();

/**
 * Function which setups the stars geometry by finding: random position, random color, random star animation speed, random star
 */
function setupStars() {
  const starGeometry = new THREE.BufferGeometry();
  const starCount = 5000;
  const positions = [];
  const colors = [];

  // Random Position and Random color
  for (let i = 0; i < starCount; i++) {
    const x = Math.floor((Math.random() - 0.5) * 1000);
    const y = Math.floor((Math.random() - 0.5) * 1000);
    const z = Math.floor((Math.random() - 0.5) * 1000);

    if (Math.sqrt(x * x + y * y + z * z) < 75) {
      continue;
    }

    positions.push(x, y, z);

    // White 50% Chance
    let r = 0.8 + Math.random() * 0.2;
    let g = 0.8 + Math.random() * 0.2;
    let b = 0.8 + Math.random() * 0.2;

    const tintType = Math.floor(Math.random() * 10);
    // Yellow 30% Chance
    if (tintType < 3) {
      b = 153 / 255;
      g = 225 / 255;
      r = 255 / 255;
    }
    // Blue 10% Chance
    else if (tintType === 3) {
      b = 255 / 255;
      g = 51 / 255;
      r = 51 / 255;
    }
    // Red 10% Chance
    else if (tintType === 9) {
      b = 50 / 255;
      g = 50 / 255;
      r = 255 / 255;
    }

    colors.push(r, g, b, 0.8);
    starPhases.push(Math.random() * Math.PI * 2);
    starSpeeds.push(0.001 + Math.random() * 0.0015);
  }

  starGeometry.setAttribute(
    "position",
    new THREE.Float32BufferAttribute(positions, 3)
  );
  starGeometry.setAttribute(
    "color",
    new THREE.Float32BufferAttribute(colors, 4)
  );
  starGeometry.setAttribute(
    "size",
    new THREE.Float32BufferAttribute(new Array(starCount).fill(0.6), 1)
  );

  const starMaterial = new THREE.PointsMaterial({
    size: 0.6,
    vertexColors: true,
    transparent: true,
    opacity: 0.8,
  });

  const stars = new THREE.Points(starGeometry, starMaterial);
  scene.add(stars);
}

/**
 * Function which makes the camera follow the mouse movement in a set window [-1, 1] from the initial point
 */
function setupCameraMovement() {
  let targetRotationX = 0;
  let targetRotationY = 0;
  let currentRotationX = 0;
  let currentRotationY = 0;

  addEventListener("mousemove", (event) => {
    if (!isAnimating) {
      return;
    }
    const mouseX = (event.clientX / window.innerWidth) * 2 - 1;
    const mouseY = -(event.clientY / window.innerHeight) * 2 + 1;

    targetRotationY = mouseX * 0.1;
    targetRotationX = mouseY * 0.1;
  });

  let frameCount = 0;
  function animate() {
    requestAnimationFrame(animate);

    currentRotationX += (targetRotationX - currentRotationX) * 0.05;
    currentRotationY += (targetRotationY - currentRotationY) * 0.05;

    camera.rotation.x = currentRotationX;
    camera.rotation.y = -currentRotationY;

    if (!isSimulationStarted) {
      camera.rotation.z += Math.random() * 0.0003;
      camera.rotation.x += Math.random() * 0.0003;
      camera.rotation.y += Math.random() * 0.0003;
    }

    frameCount++;
    changeOpacity(scene.children.find((obj) => obj.type === "Points"));
    renderer.render(scene, camera);
  }

  animate();
}

/**
 * Function changes the opacity of 1/4 of the stars every frame based on their star phase and their star speeds.
 * This is to simulate some glowing effect
 * This function was generated by ChatGPT and slightly changed to better match the needs.
 */
function changeOpacity(stars) {
  const colors = stars.geometry.attributes.color.array;

  for (let index = 0; index < colors.length / 4; index++) {
    const alphaIndex = index * 4 + 3;
    const speed = Date.now() * starSpeeds[index] + starPhases[index];
    colors[alphaIndex] = 0.3 + 0.7 * Math.abs(Math.sin(speed));
  }

  stars.geometry.attributes.color.needsUpdate = true;
}

/**
 * Function which simulates travel through space time by moving the camera position forward
 * After the animation is done, it stops all animations and dims the background.
 */
async function beginSimulation() {
  isSimulationStarted = true;
  await gsap.to(camera.position, {
    x: 0,
    y: 0,
    z: -300,
    duration: 1.5,
    ease: "power2.in",
  });

  camera.position.set(0, 0, 1300);
  await gsap.to(camera.position, {
    x: 0,
    y: 0,
    z: 0,
    duration: 1.5,
    ease: "power2.Out",
  });

  setTimeout(() => {
    isAnimating = false;
  }),
    500;
}

/** Event Listeners */
/** Function which resizes the canva if there was a change to the size of the screen */
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

document.getElementById("beginSimulation").addEventListener("click", () => {
  beginSimulation();
});

/* ########## */
/* Star Logo  */
/* ########## */

const starCanvas = document.getElementById("starCanvas");

// Setup general Scene and camera
const logoScene = new THREE.Scene();
const logoCamera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
logoCamera.position.set(2, 2, 5);

const logoRenderer = new THREE.WebGLRenderer({
  canvas: starCanvas,
  alpha: true,
  antialias: true,
});
logoRenderer.setSize(200, 200);
logoRenderer.setClearColor(0x000000, 0);

// Lighting
logoScene.add(new THREE.AmbientLight(0xffffff, 1.5));
const dirLight = new THREE.DirectionalLight(0xffffff, 10);
dirLight.position.set(2, 2, 3);
logoScene.add(dirLight);

// Load FBX model
const textureLoader = new THREE.TextureLoader();
const texture = textureLoader.load("../../images/4PointStarTexture.png");
texture.anisotropy = logoRenderer.capabilities.getMaxAnisotropy();
const loader = new THREE.FBXLoader();
let logoModel = null;

// "4 Point Star" by Yessica Servin Dominguez, used under CC Attribution 4.0. https://sketchfab.com/3d-models/4-point-star-c1481a0c1d4540818b6bcfd83dd5034b)
loader.load("../../images/4PointStar.fbx", (object) => {
  object.traverse((child) => {
    if (child.isMesh) {
      child.material.map = texture;
      child.material.needsUpdate = true;
    }
  });
  object.scale.set(1, 1, 1);
  object.rotation.set(1.7, 0, 0);

  logoScene.add(object);
  logoModel = object;

  // Center Star
  const box = new THREE.Box3().setFromObject(object);
  const size = box.getSize(new THREE.Vector3()).length();
  logoCamera.position.set(0, 0, size * 1.5);
  logoCamera.lookAt(0, 0, 0);
});

gsap.to(dirLight, {
  intensity: 3,
  duration: 1.5,
  repeat: -1,
  yoyo: true,
  ease: "sine.inOut",
});

function animate() {
  requestAnimationFrame(animate);
  if (logoModel) {
    logoModel.rotation.z += 0.0065;
  }

  logoRenderer.render(logoScene, logoCamera);
}
animate();

/**
 * Function which updates the size of the star after its position is changed to un-strech the star
 */
export function strechCamera() {
  const rectCanvas = starCanvas.getBoundingClientRect();
  logoRenderer.setSize(rectCanvas.width, rectCanvas.height, false);
  logoRenderer.setPixelRatio(rectCanvas.devicePixelRatio);
  logoCamera.aspect = rectCanvas.width / rectCanvas.height;
  logoCamera.updateProjectionMatrix();
}

// Scale star when we hover
const starContainer = document.getElementById("starContainer");
starContainer.addEventListener("mouseover", () => {
  gsap
    .to(starCanvas, {
      scale: 1.35,
    })
    .then(() => {
      strechCamera();
    });
});

starContainer.addEventListener("mouseout", () => {
  gsap
    .to(starCanvas, {
      scale: 1,
    })
    .then(() => {
      strechCamera();
    });
});
